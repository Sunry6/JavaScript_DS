/* eslint-disable @typescript-eslint/no-unused-vars */

// 虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。
// 迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
// 递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。
// 迭代：在循环中模拟求和过程，从 \(1\) 遍历到 \(n\) ，每轮执行求和操作，即可求得 \(f(n)\) 。
// 递归：将问题分解为子问题 \(f(n) = n + f(n-1)\) ，不断（递归地）分解下去，直至基本情况 \(f(1) = 1\) 时终止。
function recur(n: number): number {
  if (n === 1) return 1;
  const res = recur(n - 1);
  return n + res;
}

// tail recursion
// 有趣的是，如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为「尾递归 tail recursion」。
// 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
// 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。
// 普通递归：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。
// 尾递归：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。
function tailRecur(n: number, res: number): number {
  if (n === 0) return res;
  return tailRecur(n - 1, res + n);
}

// 递归树, 递归树的节点总数就是递归次数，而递归树的深度就是递归的层级数。
// 我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 \(n\) 的「递归树 recursion tree」。
// 从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。
// 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
// 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。
function fib(n: number): number {
  if (n === 1 || n === 2) return n - 1;
  return fib(n - 1) + fib(n - 2);
}

// 那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，这种工作机制与栈的“先入后出”原则异曲同工。
// 递归的“归”阶段实际上是将每层递归的返回值压入栈中，而递归的“递”阶段实际上是从栈中弹出返回值。因此，递归可以被看作是对系统栈的使用。
// 递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。
// 归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。

// 因此，我们可以使用一个显式的栈来模拟调用栈的行为，从而将递归转化为迭代形式：
function forLoopRecur(n: number): number {
  const stack: number[] = [];
  let res: number = 0;
  for (let i = 1; i <= n; i++) {
    stack.push(i);
  }
  while (stack.length) {
    res += stack.pop()!;
  }
  return res;
}
